(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{578:function(e,t,n){"use strict";n.r(t);var a=n(8),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),n("p",[e._v("传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但这对于熟悉使用面向对象方式的程序员来说有些棘手，因为他们用的是基于类的继承并且对象是从类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6，JavaScript程序将可以使用这种基于类的面向对象方法。 在TypeScript里，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。")]),e._v(" "),n("h2",{attrs:{id:"类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[e._v("#")]),e._v(" 类")]),e._v(" "),n("p",[e._v("下面看一个使用类的例子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter = new Greeter("world");\n')])])]),n("p",[e._v("如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个"),n("code",[e._v("Greeter")]),e._v("类。这个类有3个成员：一个叫做"),n("code",[e._v("greeting")]),e._v("的属性，一个构造函数和一个"),n("code",[e._v("greet")]),e._v("方法。")]),e._v(" "),n("p",[e._v("你会注意到，我们在引用任何一个类成员的时候都用了"),n("code",[e._v("this")]),e._v("。 它表示我们访问的是类的成员。")]),e._v(" "),n("p",[e._v("最后一行，我们使用"),n("code",[e._v("new")]),e._v("构造了Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个"),n("code",[e._v("Greeter")]),e._v("类型的新对象，并执行构造函数初始化它。")]),e._v(" "),n("h2",{attrs:{id:"继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[e._v("#")]),e._v(" 继承")]),e._v(" "),n("p",[e._v("在TypeScript里，我们可以使用常用的面向对象模式。 当然，基于类的程序设计中最基本的模式是允许使用继承来扩展一个类。")]),e._v(" "),n("p",[e._v("看下面的例子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Animal {\n    name:string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log("Slithering...");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log("Galloping...");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake("Sammy the Python");\nlet tom: Animal = new Horse("Tommy the Palomino");\n\nsam.move();\ntom.move(34);\n')])])]),n("p",[e._v("这个例子展示了TypeScript中继承的一些特征，与其它语言类似。 我们使用"),n("code",[e._v("extends")]),e._v("来创建子类。你可以看到"),n("code",[e._v("Horse")]),e._v("和"),n("code",[e._v("Snake")]),e._v("类是基类"),n("code",[e._v("Animal")]),e._v("的子类，并且可以访问其属性和方法。")]),e._v(" "),n("p",[e._v("包含constructor函数的派生类必须调用"),n("code",[e._v("super()")]),e._v("，它会执行基类的构造方法。")]),e._v(" "),n("p",[e._v("这个例子演示了如何在子类里可以重写父类的方法。 "),n("code",[e._v("Snake")]),e._v("类和"),n("code",[e._v("Horse")]),e._v("类都创建了"),n("code",[e._v("move")]),e._v("方法，重写了从"),n("code",[e._v("Animal")]),e._v("继承来的"),n("code",[e._v("move")]),e._v("方法，使得"),n("code",[e._v("move")]),e._v("方法根据不同的类而具有不同的功能。 注意，即使"),n("code",[e._v("tom")]),e._v("被声明为"),n("code",[e._v("Animal")]),e._v("类型，因为它的值是"),n("code",[e._v("Horse")]),e._v("，"),n("code",[e._v("tom.move(34)")]),e._v("调用"),n("code",[e._v("Horse")]),e._v("里的重写方法：")]),e._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Slithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n")])])]),n("h2",{attrs:{id:"公共-私有与受保护的修饰符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#公共-私有与受保护的修饰符"}},[e._v("#")]),e._v(" 公共，私有与受保护的修饰符")]),e._v(" "),n("h2",{attrs:{id:"默认为公有"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#默认为公有"}},[e._v("#")]),e._v(" 默认为公有")]),e._v(" "),n("p",[e._v("在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用"),n("code",[e._v("public")]),e._v("来做修饰；例如，C#要求必须明确地使用"),n("code",[e._v("public")]),e._v("指定成员是可见的。 在TypeScript里，每个成员默认为"),n("code",[e._v("public")]),e._v("的。")]),e._v(" "),n("p",[e._v("你也可以明确的将一个成员标记成"),n("code",[e._v("public")]),e._v("。 我们可以用下面的方式来重写上面的"),n("code",[e._v("Animal")]),e._v("类：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Animal {\n    public name: string;\n    public constructor(theName: string) { this.name = theName; }\n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n")])])]),n("h2",{attrs:{id:"理解private"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#理解private"}},[e._v("#")]),e._v(" 理解"),n("code",[e._v("private")])]),e._v(" "),n("p",[e._v("当成员被标记成"),n("code",[e._v("private")]),e._v("时，它就不能在声明它的类的外部访问。比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal(\"Cat\").name; // Error: 'name' is private;\n")])])]),n("p",[e._v("TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从哪儿来的，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。")]),e._v(" "),n("p",[e._v("然而，当我们比较带有"),n("code",[e._v("private")]),e._v("或"),n("code",[e._v("protected")]),e._v("成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个"),n("code",[e._v("private")]),e._v("成员，那么只有当另外一个类型中也存在这样一个"),n("code",[e._v("private")]),e._v("成员， 并且它们是来自同一处声明时，我们才认为这两个类型是兼容的。 对于"),n("code",[e._v("protected")]),e._v("成员也使用这个规则。")]),e._v(" "),n("p",[e._v("下面来看一个例子，详细的解释了这点：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nclass Rhino extends Animal {\n    constructor() { super("Rhino"); }\n}\n\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal("Goat");\nlet rhino = new Rhino();\nlet employee = new Employee("Bob");\n\nanimal = rhino;\nanimal = employee; // Error: Animal and Employee are not compatible\n')])])]),n("p",[e._v("这个例子中有"),n("code",[e._v("Animal")]),e._v("和"),n("code",[e._v("Rhino")]),e._v("两个类，"),n("code",[e._v("Rhino")]),e._v("是"),n("code",[e._v("Animal")]),e._v("类的子类。 还有一个"),n("code",[e._v("Employee")]),e._v("类，其类型看上去与"),n("code",[e._v("Animal")]),e._v("是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为"),n("code",[e._v("Animal")]),e._v("和"),n("code",[e._v("Rhino")]),e._v("共享了来自"),n("code",[e._v("Animal")]),e._v("里的私有成员定义"),n("code",[e._v("private name: string")]),e._v("，因此它们是兼容的。 然而"),n("code",[e._v("Employee")]),e._v("却不是这样。当把"),n("code",[e._v("Employee")]),e._v("赋值给"),n("code",[e._v("Animal")]),e._v("的时候，得到一个错误，说它们的类型不兼容。 尽管"),n("code",[e._v("Employee")]),e._v("里也有一个私有成员"),n("code",[e._v("name")]),e._v("，但它明显不是"),n("code",[e._v("Animal")]),e._v("里面定义的那个。")]),e._v(" "),n("h2",{attrs:{id:"理解protected"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#理解protected"}},[e._v("#")]),e._v(" 理解"),n("code",[e._v("protected")])]),e._v(" "),n("p",[n("code",[e._v("protected")]),e._v("修饰符与"),n("code",[e._v("private")]),e._v("修饰符的行为很相似，但有一点不同，"),n("code",[e._v("protected")]),e._v("成员在派生类中仍然可以访问。例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Person {\n    protected name: string;\n    constructor(name: string) { this.name = name; }\n}\n\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name)\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name); // error\n')])])]),n("p",[e._v("注意，我们不能在"),n("code",[e._v("Person")]),e._v("类外使用"),n("code",[e._v("name")]),e._v("，但是我们仍然可以通过"),n("code",[e._v("Employee")]),e._v("类的实例方法访问，因为"),n("code",[e._v("Employee")]),e._v("是由"),n("code",[e._v("Person")]),e._v("派生出来的。")]),e._v(" "),n("p",[e._v("构造函数也可以被标记成"),n("code",[e._v("protected")]),e._v("。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Person {\n    protected name: string;\n    protected constructor(theName: string) { this.name = theName; }\n}\n\n// Employee can extend Person\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name);\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee("Howard", "Sales");\nlet john = new Person("John"); // Error: The \'Person\' constructor is protected\n')])])]),n("h2",{attrs:{id:"readonly-修饰符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#readonly-修饰符"}},[e._v("#")]),e._v(" readonly 修饰符")]),e._v(" "),n("p",[e._v("你可以使用"),n("code",[e._v("readonly")]),e._v("关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\nlet dad = new Octopus("Man with the 8 strong legs");\ndad.name = "Man with the 3-piece suit"; // error! name is readonly.\n')])])]),n("h2",{attrs:{id:"参数属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参数属性"}},[e._v("#")]),e._v(" 参数属性")]),e._v(" "),n("p",[e._v("在上面的例子中，我们不得不定义一个受保护的成员"),n("code",[e._v("name")]),e._v("和一个构造函数参数"),n("code",[e._v("theName")]),e._v("在"),n("code",[e._v("Person")]),e._v("类里，并且立刻给"),n("code",[e._v("name")]),e._v("和"),n("code",[e._v("theName")]),e._v("赋值。 这种情况经常会遇到。"),n("em",[e._v("参数属性")]),e._v("可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前"),n("code",[e._v("Animal")]),e._v("类的修改版，使用了参数属性：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Animal {\n    constructor(private name: string) { }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n")])])]),n("p",[e._v("注意看我们是如何舍弃了"),n("code",[e._v("theName")]),e._v("，仅在构造函数里使用"),n("code",[e._v("private name: string")]),e._v("参数来创建和初始化"),n("code",[e._v("name")]),e._v("成员。 我们把声明和赋值合并至一处。")]),e._v(" "),n("p",[e._v("参数属性通过给构造函数参数添加一个访问限定符来声明。 使用"),n("code",[e._v("private")]),e._v("限定一个参数属性会声明并初始化一个私有成员；对于"),n("code",[e._v("public")]),e._v("和"),n("code",[e._v("protected")]),e._v("来说也是一样。")]),e._v(" "),n("h2",{attrs:{id:"存取器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#存取器"}},[e._v("#")]),e._v(" 存取器")]),e._v(" "),n("p",[e._v("TypeScript支持getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。")]),e._v(" "),n("p",[e._v("下面来看如何把一类改写成使用"),n("code",[e._v("get")]),e._v("和"),n("code",[e._v("set")]),e._v("。 首先是一个没用使用存取器的例子。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Employee {\n    fullName: string;\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n')])])]),n("p",[e._v("我们可以随意的设置"),n("code",[e._v("fullName")]),e._v("，这是非常方便的，但是这也可能会带来麻烦。")]),e._v(" "),n("p",[e._v("下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改employee。 我们把对"),n("code",[e._v("fullName")]),e._v("的直接访问改成了可以检查密码的"),n("code",[e._v("set")]),e._v("方法。 我们也加了一个"),n("code",[e._v("get")]),e._v("方法，让上面的例子仍然可以工作。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let passcode = "secret passcode";\n\nclass Employee {\n    private _fullName: string;\n\n    get fullName(): string {\n        return this._fullName;\n    }\n\n    set fullName(newName: string) {\n        if (passcode && passcode == "secret passcode") {\n            this._fullName = newName;\n        }\n        else {\n            console.log("Error: Unauthorized update of employee!");\n        }\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n')])])]),n("p",[e._v("我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改employee。")]),e._v(" "),n("p",[e._v("注意：若要使用存取器，要求设置编译器输出目标为ECMAScript 5或更高。")]),e._v(" "),n("h2",{attrs:{id:"静态属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态属性"}},[e._v("#")]),e._v(" 静态属性")]),e._v(" "),n("p",[e._v("到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用"),n("code",[e._v("static")]),e._v("定义"),n("code",[e._v("origin")]),e._v("，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在origin前面加上类名。 如同在实例属性上使用"),n("code",[e._v("this.")]),e._v("前缀来访问属性一样，这里我们使用"),n("code",[e._v("Grid.")]),e._v("来访问静态属性。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n")])])]),n("h2",{attrs:{id:"抽象类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[e._v("#")]),e._v(" 抽象类")]),e._v(" "),n("p",[e._v("抽象类是供其它类继承的基类。 他们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 "),n("code",[e._v("abstract")]),e._v("关键字是用于定义抽象类和在抽象类内部定义抽象方法。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("abstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n")])])]),n("p",[e._v("抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名不包含方法体。 然而，抽象方法必须使用"),n("code",[e._v("abstract")]),e._v("关键字并且可以包含访问符。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("abstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super('Accounting and Auditing'); // constructors in derived classes must call super()\n    }\n\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: method doesn't exist on declared abstract type\n")])])]),n("h2",{attrs:{id:"高级技巧"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#高级技巧"}},[e._v("#")]),e._v(" 高级技巧")]),e._v(" "),n("h2",{attrs:{id:"构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[e._v("#")]),e._v(" 构造函数")]),e._v(" "),n("p",[e._v("当你在TypeScript里定义类的时候，实际上同时定义了很多东西。 首先是类的"),n("em",[e._v("实例")]),e._v("的类型。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter: Greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n')])])]),n("p",[e._v("在这里，我们写了"),n("code",[e._v("let greeter: Greeter")]),e._v("，意思是"),n("code",[e._v("Greeter")]),e._v("类实例的类型是"),n("code",[e._v("Greeter")]),e._v("。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。")]),e._v(" "),n("p",[e._v("我们也创建了一个叫做"),n("em",[e._v("构造函数")]),e._v("的值。 这个函数会在我们使用"),n("code",[e._v("new")]),e._v("创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let Greeter = (function () {\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    Greeter.prototype.greet = function () {\n        return "Hello, " + this.greeting;\n    };\n    return Greeter;\n})();\n\nlet greeter;\ngreeter = new Greeter("world");\nconsole.log(greeter.greet());\n')])])]),n("p",[e._v("上面的代码里，"),n("code",[e._v("let Greeter")]),e._v("将被赋值为构造函数。 当我们使用"),n("code",[e._v("new")]),e._v("并执行这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有实例部分与静态部分这两个部分。")]),e._v(" "),n("p",[e._v("让我们来改写一下这个例子，看看它们之前的区别：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Greeter {\n    static standardGreeting = "Hello, there";\n    greeting: string;\n    greet() {\n        if (this.greeting) {\n            return "Hello, " + this.greeting;\n        }\n        else {\n            return Greeter.standardGreeting;\n        }\n    }\n}\n\nlet greeter1: Greeter;\ngreeter1 = new Greeter();\nconsole.log(greeter1.greet());\n\nlet greeterMaker: typeof Greeter = Greeter;\ngreeterMaker.standardGreeting = "Hey there!";\nlet greeter2:Greeter = new greeterMaker();\nconsole.log(greeter2.greet());\n')])])]),n("p",[e._v("这个例子里，"),n("code",[e._v("greeter1")]),e._v("与之前看到的一样。 我们实例化"),n("code",[e._v("Greeter")]),e._v("类，并使用这个对象。 与我们之前看到的一样。")]),e._v(" "),n("p",[e._v("再之后，我们直接使用类。 我们创建了一个叫做"),n("code",[e._v("greeterMaker")]),e._v("的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用"),n("code",[e._v("typeof Greeter")]),e._v('，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，"告诉我'),n("code",[e._v("Greeter")]),e._v('标识符的类型"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在'),n("code",[e._v("greeterMaker")]),e._v("上使用"),n("code",[e._v("new")]),e._v("，创建"),n("code",[e._v("Greeter")]),e._v("的实例。")]),e._v(" "),n("h2",{attrs:{id:"把类当做接口使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#把类当做接口使用"}},[e._v("#")]),e._v(" 把类当做接口使用")]),e._v(" "),n("p",[e._v("如上一节里所讲的，类定义会创建两个东西：类实例的类型和一个构造函数。 因为类可以创建出类型，所以你能够在可以使用接口的地方使用类。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);